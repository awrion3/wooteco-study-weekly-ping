# 쿠키 vs 세션 vs JWT

Date: 2025년 5월 12일
Status: Done

### HTTP의 비상태성(Stateless)

- 클라이언트가 보내준 정보를 서버에 저장(유지)하지 않고, 보내준 정보를 기반으로 일련의 과정들을 처리후에 클라이언트에게 응답해주는 방식
- 장점 : 스케일 아웃 - 수평 확장에 있어서 유리 (동일한 기능을 수행하는 수많은 서버로 확장가능)
- 한계 : 로그인 상태여부 - stateless 특성상 서버에 로그인 상태여부 저장 X

### HTTP의 비연결성(Connectionless)

- 요청-응답을 통해 데이터를 짧은 시간동안 주고받고 연결을 끊어버린다.
- 수천명의 유저가 서비스를 사용하더라도, 동시에 처리해야하는 요청이 줄어든다. (한번 요청을 처리하면 연결을 끊어버리고 자원을 절약하는 방식이므로)
- TCP/IP 연결을 계속 새롭게 맺어줘야함 (3-way handshakee 시간 추가)
- 웹 브라우저로 사이트를 요청하면 HTML 를 비롯한 수많은 자원들을 불필요하게 계속해서 다운로드 해야함 => **현재는 HTTP 지속연결(Persistent Connections) 로 문제점을 해결**

### Cookie

- 브라우저에 저장되어서 사용하는 작은 텍스트파일
    - 클라이언트가 웹 사이트에 접속할 때 그 사이트가 사용하는 일련의 작은 기록파일
- 접속자 장치를 인식하거나, 일부 데이터를 저장하는 역할
    - 서버가 클라이언트에 접속할 때 저장하고자 하는 정보를 응답 헤더(Cookie) 에 저장하여 전달
- Key : Value 형식의 문자열 형태

  ![Untitled](/images/spring-mvc3/Untitled.png)


### 단점

- 노출 시 id, pw 등 민감 정보까지 노출되어 보안문제 발생
- 조작당해서 들어올 수 있음
- 웹 브라우저마다 쿠키 지원 형태가 다 달라 다른 브라우저간 공유가 불가능
- 쿠키 사이즈가 4KB 로 제한되어있어 충분한 데이터를 담지 못함

### Session

- 개인 민감 정보를 노출했을 때의 단점을 방지
- 인증 정보 자체를 특정 세션 저장소에 저장하고, 이 값을 쿠키에 담아 클라이언트가 쿠키를 요청할 때 마다 세션저장소에 있는 정보랑 동일한지 확인
- 클라이언트가 쿠키를 요청할 때 마다 세션 저장소에 있는 정보랑 동일한지로 로그인을 확인
- 보안문제 발생 시, 세션 저장소를 지워버리면 됨. 세션ID로 서버에 접근해도 인증될 수단이 없다.

![Untitled](/images/spring-mvc3/Untitled%201.png)

![Untitled](/images/spring-mvc3/Untitled%202.png)

### 단점

- 세션 저장소에 문제가 발생하면 다른 인증된 유저또한 인증이 불가
- stateful 하기 때문에 http의 장점을 발휘하지 못한다. 서버를 늘릴 때 (scale out) 걸림돌
- 세션 저장소가 필수적으로 존재하기 때문에 비용발생
- 요청시 매번 세션 저장소를 조회해야 한다.

### Token

- 클라이언트에서 인증 정보를 보관하는 방법
- 유저 정보를 암호화 한 사태로 클라이언트에 담는다.

## JWT (Json Web Token)

- 인터넷 표준 인증 방식
- 인증에 필요한 정보들을 Token에 담아 암호화시켜 사용
- 서명된 토큰
    - 공개 / 개인 키를 쌍으로 사용하여 토큰에 서명할 경우, 서명된 토큰은 개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증할 수 있음

### JWT의 구조

![Untitled](/images/spring-mvc3/Untitled%203.png)

![Untitled](/images/spring-mvc3/Untitled%204.png)

- 각각의 구성요소가 점(.) 으로 구분되어 있는 형태
1. Header

    ```json
    {
    		"typ" : "JWT",
    		"alg" : "HS512"
    }
    ```

    - 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용되었는지 저장
    - ex) JWT 타입, HS512 개인키 알고리즘 적용
2. PAYLOAD

    ```json
    {
    		"sub" : "1",
    		"iss" : "ori",
    		"exp" : 1636989718,
    		"iat" : 1636987918
    }
    ```

    - 사용자 혹은 토큰에 대한 property 저장 (Claim)
    - 표준 스펙 7가지 : `iss` : 토큰 발급자, `sub` : 토큰 제목, `aud` : 토큰 대상자, `exp` : 토큰 만료 시간, `nbf` : 토큰 활성 날짜, `iat` : 토큰 발급 시간, `jti` : JWT 토큰 식별자
    - 표준 스펙을 모두 포함해야 하는 것은 아니고, 상황에 따라 사용
        - 필요 시 추가 가능
    - 민감한 정보를 담지 않는 것이 중요
        - json이 디코딩 되어있을 뿐이지 특별히 암호화가 걸려있는 것이 아님
3. Signature
    - 암호화 되어있음
    - header를 디코딩한 값, payload를 디코딩한 값을 합치고 서버가 가지고 있는 개인키를 가지고 암호화
    - 서버에 있는 개인키로만 암호화를 풀 수 있으므로 다른 클라이언트는 임의로 Signature를 복호화 할 수 없음

### 장점

- 이미 토큰 자체가 인증된 정보이므로 세션 저장소와 같은 별도의 인증 저장소가 필수적으로 필요하지 않다.
- 세션과는 다르게 클라이언트의 상태를 서버가 저장해두지 않아도 된다.
- signature를 공통키 개인키 암호화를 통해 막아두었기 때문에 보안성이 늘어난다.
- 다른 서비스에 이용할 수 있는 공통적인 스펙으로 사용할 수 있다.

### 단점

- base64 인코딩을 통한 정보를 전달하므로 전달량이 많다.
- payload 에는 민감 정보를 저장할 수 없다.
- **토큰이 탈취당하면 만료될 때 까지 대처가 불가능하다**.
    - exp(Expiration Time) 만료시간을 짧게 가져감으로써 해결
    - 사용자는 불편한 경험을 느낌
- 대처 방안
    - Sliding Session
        - 서비스를 계속 사용하고 있는 유저에 대해 만료 시간을 연장시켜줌
        - 특정 Action을 유저가 행동 시 새롭게 만료시간을 늘린 JWT를 다시 제공
    - Refresh Token :
        - Access Token을 Refresh 해주는 것을 보장하는 토큰
        - JWT 를 처음 발급할 때 Access Token 과 함께 Refresh Token 발급
        - 비교적 긴 시간의 만료시간을 가짐
        - Access Token이 만료됨을 확인받고 Refresh Token으로 새로운 Access Token을 발급받음

### Access Token & Refresh Token

토큰이 탈취당했을 때를 대비하여 나온 해결책 → 유효 기간을 통한 해결

유효 기간이 다른 JWT 토큰 (Access Token 과 Refresh Token) 을 통해 해결

- Access Token : 유효기간이 짧다
- Refresh Token : 유효기간이 길다
- 평소의 API 통신에서는 Access Token 사용, 만료되어 갱신이 필요할 시 Refresh Token 사용

### 통신 과정

1. 로그인 인증에 성공한 클라이언트는 `Refresh Token`과 `Access Token` 두 개를 **서버로부터 받는다**.
2. 클라이언트는 `Refresh Token`과 `Access Token`을 **로컬**에 저장해놓는다.
3. 클라이언트는 **헤더**에 Access Token을 넣고 API 통신을 한다. **(Authorization)**
4. 일정 기간이 지나 `Access Token`의 **유효기간이 만료**되었다.
    1.  Access Token은 이제 유효하지 않으므로 **권한이 없는 사용자**가 된다.
    2. 클라이언트로부터 유효기간이 지난 Access Token을 받은 서버는 [401 (Unauthorized)](https://www.rfc-editor.org/rfc/rfc6750#section-6.2.2) 에러 코드로 응답한다.
    3. `401`를 통해 클라이언트는 `invalid_token` (유효기간이 만료되었음)을 알 수 있다.
5. **헤더**에 Access Token 대신 `Refresh Token`을 넣어 **API를 재요청**한다.
6. Refresh Token으로 사용자의 권한을 확인한 서버는 **응답쿼리 헤더**에 **새로운 Access Token**을 넣어 응답한다.
7. 만약 `Refresh Token`도 **만료**되었다면 서버는 동일하게 **401 error code**를 보내고, 클라이언트는 **재로그인**해야한다

- Access Token 이 통신이 빈번하기 때문에 보안에 취약하지만, 만약 탈취에 성공하더라도 유효기간이 짧아 활용을 제대로 하지 못한다.
- 만약 탈취해서 유효기간을 늘리더라도, Payload의 만료기간을 늘려도 Signature는 기존의(Header+ Payload)를 비밀키로 암호화 한 것이기 때문에 값이 바뀌지 않는다.
- Refresh Token 이 통신빈도가 적어도, 탈취 위험이 없는것은 아니다. 이를 예방하기 위해 **Refresh Token Rotation** 이 제시되는데, Access Token을 재요청 할 때 마다 Refresh Token도 새로 발급받아야 한다.
- Refresh Token의 실질적인 만료기간이 줄어드므로, 보안 위험이 줄어든다.
- 만약, 사용자가 계속해서 서비스를 이용한다면, 리프레시토큰이 계속 연장되어 이론상으로 사용자는 토큰을 계속 재발급 받을 수 있다.
