# 1. 트랜잭션

---

- MyISAM 스토리지 엔진 : AUTO-COMMIT on 하고나서 트랜잭션 지원 X
    - 쿼리 오류로 실패해도 부분 업데이트 (Partial Update) 밖에 안됨
- InnoDB 스토리지 엔진 : AUTO-COMMIT on 하고나서 트랜잭션 지원 O


- 게시판에 게시물을 작성한 후 저장 버튼을 클릭 했을 때의 예시

```sql
1. 처리 시작
	=> 데이터베이스 커넥션 생성
	=> 트랜잭션 시작
2. 사용자 로그인 여부 확인
3. 사용자 글쓰기 내용 오류 여부 확인
4. 첨부로 업로드 된 파일 확인 및 저장
5. 사용자 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장
	<= 트랜잭션 종료 (COMMIT)
	<= 데이터베이스 커넥션 반납
10. 처리 완료
```

- 문제점
    1. 실제 DBMS를 사용해 데이터를 저장하는 작업(트랜잭션)은 5번에서 시작함
        - 아무리 2,3,4번 작업이 빨리 진행된다 하더라도 그 사이에 DBMS의 트랜잭션을 포함시킬 필요가 없음
        - 데이터베이스 커넥션 수는 한정적이라 각 단위가 커넥션을 오래 소유할 수록 사용 가능한 커넥션 수는 줄어드는 것
        - 계속 줄어들면 각 단위 프로그램에서 커넥션을 대기하는 상황이 발생할 수 있음
    2. 메일 전송이나 FTP 파일 전송 작업 또는 네트워크 통한 원격 서버 통신 등의 작업은 DBMS 트랜잭션 내에서 제거하는 것이 좋음
        - 프로그램 실행동안 메일 서버와 통신 불가하게 되면 웹서버 뿐 만이 아닌 DBMS 서버까지 위험해질 수 있음
    3. 사용자가 입력한 정보를 저장하는 5,6번은 하나의 트랜잭션으로 묶여야 함
        - 7번은 조회이므로 트랜잭션 포함 필요 X
        - 9번은 이전 작업과 성격이 다르므로 5,6번과는 묶을 필요 없고 별도의 트랜잭션으로 분리하는 게 좋음


- 위를 개선한 트랜잭션 상태

```sql
1. 처리 시작
2. 사용자 로그인 여부 확인
3. 사용자 글쓰기 내용 오류 여부 확인
4. 첨부로 업로드 된 파일 확인 및 저장
	=> 데이터베이스 커넥션 생성
	=> 트랜잭션 시작
5. 사용자 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
	<= 트랜잭션 종료 (COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
	=> 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장
	<= 트랜잭션 종료 (COMMIT)
	<= 데이터베이스 커넥션 종료 (또는 커넥션 풀에 반납)
10. 처리 완료
```

- 네트워크 작업이 있는 경우는 반드시 트랜잭션에서 배제해야 함
    - DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태가 될 수 있음

# 2. MySQL 엔진의 잠금

---

- MySQL 잠금
    1. 스토리지 엔진 레벨의 잠금
        - 스토리지 엔진 간 상호 영향 미치지 않음
    2. MySQL 엔진 레벨의 잠금 (스토리지 엔진을 제외한 나머지 부분)
        - 모든 스토리지 엔진에 영향을 미침
    - MySQL에서는 글로벌 락, 테이블 락, 메타데이터 락, 네임드 락을 제공

## 1. 글로벌 락 (Global Lock)

```sql
FLUSH TABLES WITH READ LOCK
```

- 한 세션에서 글로벌 락을 획득하면, 다른 세션에서 SELECT를 제외한 DDL, DML 문장을 실행할 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남음
- 영향 범위 : MySQL 서버 전체
    - 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향 미침
- 사용처 : 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 `mysqldump`로 일관된 백업을 받아야 할 때 사용


- **주의 사항** : 글로벌 락 명령어를 실행하면 그와 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금
    - 위 명령어가 실행되기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행 됐을 경우

      ⇒ 해당 테이블의 읽기 잠금을 걸기 위해 먼저 실행된 SQL과 그 트랜잭션이 완료될 때까지 기다려야 함

    - 읽기 잠금을 걸기 전 테이블을 flush 해야하기 때문에 테이블에 실행 중인 모든 쿼리가 완료 되어야 함
    - 장시간 실행되는 쿼리와 글로벌 락을 거는 명령이 최악의 케이스로 실행 될 경우

      ⇒  MySQL 서버의 모든 테이블에 대해 INSERT, UPDATE, DELETE 쿼리가 오랜 시간 동안 실행되지 못하고 기다릴 수 있음

    - 글로벌 락은 MySQL 서버의 모든 테이블에 영향을 끼치므로 웹 서비스용 MySQL 서버에는 가급적 사용하지 않는 것이 좋음


- InnoDB가 MySQL의 베이스 스토리지 엔진으로 채택 된 후
    - 좀 더 가벼운 글로벌 락이 필요해짐 (왜?)
    - InnoDB가 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없어짐
    - 8.0 버전부터는 Xtrabackup이나 Enterprise Backup 같은 백업 툴들의 안정적인 실행을 위해 **백업 락**이 도입 됨

### 1.1 백업 락

```sql
LOCK INSTANCE FOR BACKUP
```

- 특정 세션에서 백업 락을 얻으면 모든 세션에서 테이블 스키마나 사용자 인증 관련 데이터를 변경할 수 없게 됨
    1. 데이터베이스 및 테이블 등 모든 객체 생성, 변경, 삭제 불가
    2. `REPAIR TABLE`, `OPTIMIZE TABLE` 명령 불가
    3. 사용자 관리 및 비밀번호 변경 불가
- 하지만 또 테이블 데이터 변경은 허용됨
- MySQL 서버 구성 : 소스 서버 + 레플리카 서버
    - 주로 백업은 레플리카 서버에서 진행 됨
- 백업이 `FLUSH TABLES WITH READ LOCK`  명령을 이용해 글로벌 락을 획득하면 복제는 백업 시간만큼 지연될 수밖에 없음
- 레플리카 서버에서 백업을 실행하는 도중 소스 서버에 문제가 생기면 레플리카 서버의 데이터가 최신 상태가 될 때까지 서비스를 멈춰야 할 수도 있음
- 백업 툴이 실행되는 도중에 스키마 변경이 실행되면 백업은 실패하게 됨
    - 정상적으로 복제는 실행되지만 백업 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 것이 핵심
- 일반적인 데이터 변경은 허용하면서도 물리적 구조 변경에 대한 문제 발생은 예방할 수 있음

## 2. 테이블 락

```sql
LOCK TABLES table_name [ READ | WRITE ]
```

- 개별 테이블 단위로 설정되는 잠금
- MyISAM, InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정 가능
- 명시적으로 획득한 잠금은 `UNLOCK TABLES`  명령으로 잠금을 반납할 수 있음
    - 명시적인 테이블 락도 온라인 작업에 상당한 영향을 미치므로 애플리케이션에서 사용할 필요가 거의 없음

- 묵시적 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생함
    - 쿼리가 실행되는 동안 자동으로 획득 → 쿼리 완료 후 자동 해제
- InnoDB 테이블은 스토리지 엔진 차원에서 레코드 기반 잠금을 제공

  ⇒ 단순 데이터 변경 쿼리로 묵시적 테이블 락이 설정되진 않음

    - 테이블 락은 설정 되지만 대부분의 DML(데이터 변경) 쿼리에서는 무시되고 DDL(스키마 변경) 쿼리의 경우에만 영향을 미침

## 3. 네임드 락 → 어따 쓰는지 이해가 안감

```sql
-- 'my_lock'이라는 문자열에 대해 락 획득
-- 이미 락 사용중이면 2초 동안만 대기 (2초 이후는 자동 락 포기)
SELECT GET_LOCK('my_lock', 2);
```

- 임의의 문자열에 대해 잠금 설정
- 대상이 테이블이나 레코드 또는 `AUTO_INCREMENT` 같은 데이터베이스 객체가 아님
- 단순 사용자가 지정한 String에 대해 획득하고 반납하는 잠금
- 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용해서 해결 가능
    - ex ) DB 서버 1대에 웹 서버 5대가 직접 접속한 상황에서 웹 서버들이 어떤 정보를 동기화해야 하는 경우

```sql
// 'my_lock'이라는 문자열에 대해 락이 설정되어 있는지 확인
SELECT IS_FREE_LOCK('my_lock');
```

```sql
// 'my_lock'이라는 문자열에 대해 획득 했던 락을 반납
SELECT RELEASE_LOCK('my_lock');
```

- 위 모든 쿼리는 정상적으로 락 획득하거나 해제한 경우 1 반환
    - 아니면 NULL 또는 0 반환
- 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용됨
    - 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 될 수 있음

      ⇒ 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 간단히 해결 가능

- 8.0 버전 이후로는 네임드 락을 중첩해 사용이 가능하고, 현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능도 추가 됨

    ```sql
    SELECT GET_LOCK('mylock_1', 10);
    // mylock_1 관련 작업 수행
    SELECT GET_LOCK('mylock_2', 10);
    // mylock_2 관련 작업 수행
    
    SELECT RELEASE_LOCK('mylock_2');
    SELECT RELEASE_LOCK('mylock_1');
    
    // 두 개를 동시에 모두 해제
    SELECT RELEASE_ALL_LOCKS();
    ```


**네임드 락이 유용한 경우**

1. **일괄 업데이트 (Batch Update)**
    - 대량의 데이터를 한꺼번에 변경하는 경우
2. **중복 실행 방지**
    - 동일한 작업이 여러 번 동시에 실행되지 않도록 제한

**3. 트랜잭션 겹침 방지**

- 같은 데이터 범위를 갱신하는 여러 트랜잭션이 동시에 실행되는 경우
- 근데 잘 안쓰임

## 4. 메타데이터 락

- 데이터베이스 객체 (테이블, 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
- 명시적으로 획득하거나 해제할 수 있는 것은 아님

```sql
RENAME TABLE table_a TO table_b;
```

- 위처럼 테이블 이름을 변경하는 경우 자동으로 획득
    - 원본 이름, 변경될 이름 두 개에 모두 한꺼번에 락을 획득함

- 실시간으로 테이블을 바꿔야 하는 상황이 배치 프로그램에서 자주 발생함

```sql
-- 임시 테이블(rank_new)에 서비스용 랭킹 데이터 생성
-- 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업
-- 새로 만들어진 랭킹 테이블 (rank_new)을 서비스용으로 대체하고자 하는 경우
RENAME TABLE rank TO rank_backup, rank_new TO rank;
```

- 두 RENAME 작업을 한꺼번에 실행하면 실제 애플리케이션에서 `Table not found 'rank'` 같은 오류 발생 X
- 하지만 두 문장으로 쪼개 수행하면 `Table not found 'rank'`오류가 발생할 수 있음

    ```sql
    RENAME TABLE rank TO rank_backup;
    RENAME TABLE rank_new TO rank;
    ```

- 때로는 메타데이터 잠금과 InnoDB의 트랜잭션을 동시에 사용해야 하는 경우도 있음
    - ex ) INSERT만 실행되는 로그 테이블을 가정했을 때 웹 서버 액세스 로그를 저장만 하므로 UPDATE, DELETE가 없음

        ```sql
        CREATE TABLE access_log(
        	id BIGINT NOT NULL AUTO_INCREMENT,
        	client_ip INT UNSIGNED,
        	access_dttm TIMESTAMP,
        	...
        	PRIMARY KEY(id)
        );
        ```

    - 테이블 구조를 변경해야 할 요건이 발생했을 때, 시간이 너무 오래 걸리는 경우라면 Online DDL이 실행되는 동안 누적된 버퍼 크기 등 고민해야 할 문제가 많음
    - 더 큰 문제는 MySQL 서버의 DDL은 단일 스레드로 작동 → 많은 시간 소요
    - 이 때는 새로운 구조의 테이블을 생성하고 먼저 최근(1시간 직전 또는 하루 전) 데이터까진 프라이머리 키인 id 값을 범위별로 나눠 여러 개의 스레드로 빠르게 복사함

        ```sql
        mysql> CREATE TABLE access_log_new(
        	id BIGINT NOT NULL AUTO_INCREMENT,
        	client_ip INT UNSIGNED,
        	access_dttm TIMESTAMP,
        	...
        	PRIMARY KEY(id)
        ) KEY_BLOCK_SIZE=4;
        
        -- 4개 스레드를 이용해 id 범위 별 레코드를 신규 테이블로 복사
        mysql_thred_1> INSERT INTO acess_log_new SELECT * FROM access_log WHERE id>=0 AND id<10000;
        mysql_thred_2> INSERT INTO acess_log_new SELECT * FROM access_log WHERE id>=10000 AND id<20000;
        mysql_thred_3> INSERT INTO acess_log_new SELECT * FROM access_log WHERE id>=20000 AND id<30000;
        mysql_thred_4> INSERT INTO acess_log_new SELECT * FROM access_log WHERE id>=30000 AND id<40000;
        ```

    - 나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 프로그램 중단 없이 실행할 수 있음
    - 남은 테이블을 복사하는 동안 테이블 잠금으로 INSERT 할 수 없게 됨
        - 그래서 가능하면 미리 아주 최근 데이터까지 복사해 둬야 잠금 시간 최소화 + 서비스 영향 줄일 수 있음

    ```sql
    mysql> SET autocommit=0; -- 트랜잭션을 autocommit으로 실행 (명시적 트랜잭션 시작 불가)
    
    -- 작업 대상 테이블 2개에 대해 테이블 쓰기 락 획득
    LOCK TABLES access_log WRITE, access_log_new WRITE;
    
    -- 남은 데이터 복사
    SELECT MAX(id) as @MAX_ID FROM access_log_new;
    INSERT INTO access_log_new SELECT * FROM access_log WHERE pk>@MAX_ID;
    COMMIT;
    
    -- 새로운 테이블로 데이터 복사가 완료되면 RENAME 명령으로 새로운 테이블을 서비스로 투입
    RENAME TABLE access_log TO accesss_log_old, access_log_new TO access_log;
    UNLOCK TABLES;
    
    -- 불필요한 테이블 삭제
    DROP TABLE access_log_old;
    ```


## 3. InnoDB 스토리지 엔진 잠금

- MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재함
- 레코드 기반 잠금 방식으로 MyISAM보단 뛰어난 동시성 처리 제공함
- 이원화 된 잠금 처리 탓에 InnoDB 스토리지 엔진의 잠금 정보를 MySQL 명령으로 접근하기가 까다로움
- 최근 버전 InnoDB의 트랜잭션, 잠금, 잠금 대기 중인 트랜잭션 목록을 조회할 수 있는 방법이 도입 됨
- 현재 어떤 트랜잭션이 어떤 잠금을 대기하고 있는지, 해당 잠금을 어느 트랜잭션에서 갖고 있는지 찾아내고, 장시간 잠금을 갖고 있는 클라이언트를 찾아 종료시킬 수 있음

### 1. InnoDB 스토리지 엔진의 잠금

- 레코드 기반 잠금 기능 제공
- 락 정보가 상당히 작은 공간으로 관리되므로 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업 되는 경우(락 에스컬레이션)는 없음
- 레코드와 레코드 사이 간격을 잠그는 갭 락이라는 것도 있음
1. **레코드 락**
    - 레코드 자체만을 잠그는 것
    - 레코드 자체가 아니라 인덱스의 레코드를 잠금
    - 인덱스가 하나도 없는 테이블이어도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정함
    - 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해 잠그지 않고 레코드 자체에 대해서만 락을 걺
2. **갭 락**
    - 레코드와 바로 인접한 레코드 사이 간격만을 잠그는 것
    - 레코드와 레코드 사이 간격에 새로운 레코드가 생성되는 것을 제어함
3. **넥스트  키 락**
    - 레코드 락 + 갭 락
    - innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화되면 변경 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금 걸림
    - 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적
        - 하지만 넥스트 키 락, 갭 락으로 인해 데드락이나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생

          ⇒ 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔 넥스트 키 락이나 갭 락을 줄이는 것이 좋음

4. **자동 증가 락**
    - AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련 번호 값을 가져야 함
    - InnoDB 스토리지 엔진 내부적으로 이를 위해 자동 증가 락이라는 테이블 수준 잠금을 사용함
    - 트랜잭션 관계 없이 INSERT, REPLACE 문장에서 자동 증가 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨
    - 테이블에 단 하나만 존재함 → 두 개의 INSERT가 동시에 실행될 경우 하나의 쿼리가 락을 걸면 나머지 쿼리는 락을 대기해야 함
        - 해당 칼럼에 명시적으로 값을 설정해도 자동 증가 락을 걸게 됨
    - 명시적 획득/해제 방법은 없음
    - innodb_autoinc_lock_mode 다시 찾아보기
    - 자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유는 AUTO_INCREMENT 잠금을 최소화하기 위함
        - INSERT 실패해도 한 번 증가된 값은 다시 줄어들지 않음

### 2. 인덱스와 잠금

- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락 걸어야 함
- ex ) employees 테이블에 first_name 칼럼만 멤버로 담긴 ix_firstname이라는 인덱스가 준비되어 있음 (`KEY ix_firstname (first_name)` )
    - employees 테이블에서 first_name=’Georgi’인 사원은 전체 253명이 있으며, 그 중 last_name = ‘Klassen’인 사원은 딱 한 명 있을 경우
    - employees 테이블에서 위 사원의 입사 일자를 오늘로 변경하는 쿼리를 실행할 경우

        ```sql
        UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
        ```

        - 인덱스를 이용할 수 있는 조건이 first_name 조건이고, last_name은 인덱스가 없음

          ⇒ 레코드는 1건 업데이트 될 것이고 253건의 레코드가 락되어야 함

- 만약 인덱스도 없다면 풀 테이블 스캔으로 UPDATE를 해야하기에 테이블의 모든 레코드를 잠그게 됨

### 3. 레코드 수준의 잠금 확인 및 해제

- 테이블 잠금에서는 잠금 대상이 테이블 자체이므로 쉽게 문제의 원인이 발견되고 해결될 수 있음
- 레코드 수준 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용 되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않음
- 강제 잠금 해제는 KILL로 MySQL 서버 프로세스를 강종 하면 됨
- ex )

    ```sql
    connection1> BEGIN;
    connection1> UPDATE employees SET birth_date=NOW() WHERE emp_no=100001;
    
    connection2> UPDATE employees SET hire_date=NOW() WHERE emp_no=100001;
    
    connection3> UPDATE employees SET birth_date=NOW(), hire_date=NOW() WHERE emp_no=100001;
    ```

    - UPDATE 명령 3개를 실행 했을 때 프로세스 목록 조회 결과

    | id | time | state | info |
        | --- | --- | --- | --- |
        | 17 | 607 |  | NULL |
        | 18 | 22 | updating | UPDATE employees SET birth_date=NOW() … |
        | 19 | 21 | updating | UPDATE employees SET birth_date=NOW() …  |
- 이후에 잠금 대기 순서를 봤을 때, 현재 대기 중인 스레드는 18, 19번임 (여기 내가 생략했음)
    - 18은 17을, 19는 17, 18을 기다리는 중
    - 17이 너무 오래 멈춰있으면 아래처럼 KILL 해서 잠금 해제해줄 수 있음
        
        ```sql
        KILL 17;
        ```


## 4. MySQL의 격리 수준

- 트랜잭션 격리 수준 : 여러 트랜잭션이 동시 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경, 조회하는 데이터를 볼 수 있게 허용할지 말지 결정하는 것
- 뒤로 갈수록 각 트랜잭션 간 데이터 격리 정도가 높아짐
    - 동시 처리 성능도 떨어짐
- 격리 수준 높아질수록 MySQL 서버의 성능이 떨어지진 않음 (SREIALIZABLE 제외)

|  | DIRTY READ | NON_REPEATABLE READ | PHANTOM READ |
| --- | --- | --- | --- |
| READ UNCOMMITTED | O | O | O |
| READ COMMITTED | X | O | O |
| REPEATABLE READ | X | X | O (InnoDB는 없음) |
| SERIALIZABLE | X | X | X |
- 일반적인 온라인 서비스 용도의 DB는 READ COMMITTED와 REPEATABLE READ 중 하나를 사용함

### 1. READ UNCOMMITTED

- 각 트랜잭션 변경 내용이 commit, rollback 여부 상관 없이 다른 트랜잭션에서 보임
- 변경사항을 커밋하지 않았어도 다른 트랜잭션에서 해당 내용이 보임
- 변경한 데이터를 보고 처리한 트랜잭션은 해당 데이터가 롤백 됐어도 그 데이터가 롤백 됐는지 모른 채 계속 처리하게 될 것

  ⇒ **“Dirty Read”** 현상


### 2. READ COMMITTED

- Dirty Read는 발생하지 않음
- 커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있게 됨
- 과정
    1. 변경이 발생하면 변경 이전 값은 Undo 영역에 저장됨
    2. 해당 대상을 조회 하려는 트랜잭션이 데이터를 조회하면 Undo 영역의 백업 된 데이터가 조회 됨
    3. 변경 발생시킨 트랜잭션에서 커밋 되면 그 때 부터는 커밋된 내용으로 조회 됨
- NON-REPEATABLE READ
    - 항상 같은 결과를 반환해야 한다는 문제에서 어긋남
    - 조회 시점에 따라 조회되는 데이터가 달라지기 때문 (커밋 여부에 따라 달라짐)
- SELECT도 기본적으로 트랜잭션 범위 내에서만 작동함 ( 이거 내용 다시 알아봐야 할 듯 )
    - 아무리 다른 트랜잭션에서 해당 데이터를 변경하고 커밋 해도 그럼

### 3. REPEATABLE READ

- MVCC를 위해 Undo 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과가 보이도록 보장
- 바이너리 로그를 가진 MySQL 서버는 최소 이 수준 이상을 사용해야 함
- 여기부턴 NON-REPEATABLE READ 발생 X
- MVCC (Multi Version Concurrency Control) 방식
    - 트랜잭션 롤백 가능성에 대비해 변경되기 전 레코드를 Undo 공간에 백업해두고 실제 레코드 값을 변경함
- READ COMMITTED와의 차이점
    - Undo 영역에 백업된 레코드 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐 차이

- 모든 InnoDB 트랜잭션은 고유 트랜잭션 번호를 가짐
- Undo 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호 포함되어 있음
- Undo 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제함
- REPEATABLE READ 격리 수준에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 Undo 영역 데이터는 삭제 불가
- 특정 트랜잭션 번호 구간 내에서 백업된 Undo 데이터가 보존돼야 함

  (여기 다시 책 보기)

- PHANTOM READ
    - SELECT 쿼리 결과가 다르고, 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상
    - SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데, Undo 레코드는 잠금을 걸 수 없음
    - 그래서 SELECT .. FOR UPDATE나 SELECT … LOCK IN SHARE MODE로 조회되는 레코드는 Undo 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드 값을 가져오게 되는 것

### 4. SERIALIZABLE

- 읽기 작업도 읽기 잠금을 획득 해야만 하고, 동시에 다른 트랜잭션은 해당 레코드 변경 불가
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근 할 수 없음
- InnoDB 스토리지 엔진에선 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 유령 현상이 안나타나므로 굳이 쓸 필요 없는 수준이긴 함
