# ❓ 잠금과 트랜잭션

### 잠금

여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할

### 격리 수준

하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

# 💡트랜잭션

## 🤔 보충 : 스토리지 엔진이란?

스토리지 엔진은 MySQL에서 데이터를 저장하고 관리하는 방식을 결정하는 시스템이다. 즉, 데이터를 어떻게 저장하고 불러올지를 결정하는 데이터베이스의 파일 시스템 같은 역할을 한다.

## MyISAM 스토리지 엔진

- 빠른 읽기 속도 : SELECT 속도가 빠르다.
- 트랜잭션 미지원
- 테이블 단위 락 : 데이터를 변경할 때 전체 테이블을 잠가서 여러 사용자가 동시에 수정하면 성능이 저하된다.
- 파일 기반 저장

→ 블로그, 뉴스 사이트 처럼 읽기(조회)가 많은 경우 유리

→ 로그 데이터 저장

## MEMORY 스토리지 엔진

- 초고속 성능 : 데이터를 메모리에 저장하므로 읽기/쓰기 속도가 빠름
- 휘발성 : MYSQL를 재시작하면 모든 데이터가 사라짐
- 테이블 락 사용
- 고정 길이 데이터만 저장 가능 : TEXT, BLOB 같은 가변 길이 데이터 저장 불가

→ 세션 데이터 저장(로그인 정보), 캐싱 시스템

## InnoDB 스토리지 엔진

- 트랜잭션 지원 : 데이터 안정성이 높음
- 레코드 단위 락 : 데이블 전체가 아니라 특정 행만 잠금 → 동시 처리가 원할
- 외래 키 지원 : 데이터 무결성 보장
- 데이터와 인덱스를 함께 저장

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100)
) ENGINE=InnoDB;

ENGINE = InnoDb, ENGINE = MyISAM, ENGINE = MEMORY

```



## ❌ 트랜잭션 주의사항

트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉, 프로그램 코드에서 트랜잭션의 범위를 최소화해야한다.

- 커넥션 생성(커넥션 풀에서 가져오는) 작업은 커넥션을 사용하기 직전에 가져오자. 일반적으로 데이터베이스 커넥션은 개수가 제한적이여서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질 수록 사용 가능한 여유 커넥션 수는 줄어든다.
- 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.
- 작업 성격에 맡게 트랜잭션을 묶자

## ❓ MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.

### 🤔 MySQL 엔진 레벨 잠금

MySQL 서버 자체에서 적용하는 잠금으로, SQL을 처리하는 MySQL 엔진에서 관리된다.

이 잠금은 스토리지 엔진과 무관하게 작동하며, 주로 테이블 단위의 잠금을 담당한다.

1. 네이티브 테이블 락
    1. MyISAM, MEMORY, CSV와 같은 테이블 기반 스토리지 엔진에서 사용
    2. LOCK TABLES 문을 사용하여 명시적으로 테이블 잠금을 설정 가능
    3. InnoDB는 기본적으로 사용하지 않음 → 레코드 단위로 락을 건다.
2. 메타데이터 락
    1. 테이블 구조를 변경하는 ALTER TABLE, DROP TABLE 같은 DDL 실행시 적용
    2. 여러 트랜잭션이 동시에 스키마를 변경 하지 못하도록 보호
3. 네임드 락
    1. GET_LOCK(”lock_name”, timemout) 함수를 이용하여 사용자 정의 잠금 설정

### 🤔  스토리지 엔진 레벨 잠금

MySQL은 여러 스토리지 엔진을 지원하는데 각 엔진이 자체적으로 잠금 전략을 관리한다.

1. InnoDB (트랜잭션 지원, 레코드 기반 잠금)
    1. 레코드 락
    2. 갭 락 → 레코드 사이의 간격을 잠가 팬텀 리드 방지
    3. 넥스트 키 락 → 레코드 락 + 갭 락을 결합하여 range 검색 시 충돌 방지
2. MyISAM (테이블 단위 잠금)
    1. 테이블 락
    2. 읽기 작업과 쓰지 작업이 동시해 수행될 수 없음
3. MEMORY (메모리 기반, 테이블 단위 잠금)
    1. 빠른 조회 성능을 위해 테이블 잠금을 사용

## MySQL의 엔진 잠금 레벨 락의 종류

### 🤔 글로벌 락

```sql
FLUSH TABLES WITH READ LOCK
```

글로벌 락은 FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 가운데 가장 범위가 크다. 실행과 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 건다. 그렇기에 명령이 실행되기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행되었다면 해당 트랜잭션이 종료될 때 까지 기다려야한다.

### 🤔 백업 락

InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없다. 또한 MySQL 8.0 부터 InnoDB가 기본 스토리지 엔진으로 채택이 되면서 조금 더 가벼운 글로벌 락이 필요했다. 그래서 백업 락이 등장했다.

```sql
LOCK INSTANCE FOR BACKUP;
-- 백업 실행
UNLOCK INSTANCE;
```

백업 락을 획득하면 모든 세션에서 다음과 같이 테이블의 스키마나 사용자 인증 관련 정보를 변경할 수 없다. 하지만 일반적인 테이블의 데이터 변경은 혀용된다.

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE 과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

### 💡 소스 서버와 레플리카 서버

소스 서버와 레플리카 서버는 데이터베이스 복제에서 등장하는 개념으로, 주 - 종 구조이다.

1. 소스 서버

소스 서버는 원본 데이터를 가지고 있으며, 변경 사항을 레플리카 서버로 전송하는 역할읗 한다.

즉, 데이터 추가/ 수정/ 삭제가 일어나는 중앙 서버이다.

- 데이터의 원본을 관리
- 모든 쓰기 작업을 처리
- 데이터 변경 사항을 레플리카 서버로 전송
- 로그를 기록하여 복제 수행
1. 레플리카 서버

레플리카 서버는 소스 서버의 데이터를 복사하여 읽기 작업을 처리하는 역할을 한다. 즉, 소스 서버의 변경 사항을 실시간으로 받아와 동기화하며, 보통 읽기 전용으로 사용된다.

- 소스 서버에서 데이터를 받아와 동기화
- 보통 읽기 작업을 수행하여 부하를 분산
- 장애 발생 시 소스 서버를 대체할 수도 있음
- 데이터 동기화 상태를 유지하기 위해 소스 서버의 변경 로그를 지속적으로 받아 처리

만약 소스 서버에서 장애가 생기면 레플리카 서버에서 최신 백업 데이터 파일을 가져와 복구함

### 🤔 테이블락

테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.

```sql
LOCAK TABLES [테이블 명] [READ:WRITE]
```

### 🤔 네임드 락

GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 이 잠금은 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니다.

```sql
SELECT GET_LOCK('process_lock', 5);
SELECT RELEASE_LOCK('process_lock');

```

### 🤔 메타데이터 락

메타데이터 락은 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다. 메타데이터 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니고 RENAME TABLE tab_a TO tab_b 와 같이 테이블 이름을 변경하는 경우 자동으로 얻게 된다.

## 스토리지 엔진 레벨 잠금

### 🤔 레코드 락

레코드 자체만을 잠그는 것을 레코드 락이라고 한다. 다른 DMBS의 레코드 락과 동일한 역할을 한다. 하지만 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.

### 🤔 갭 락

레코드 자체가 아니라 레코드와 인접한 레코드 사이의 간격만을 잠그는 것이다. 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어한다. 갭 락은 그 자체보다는 넥스트 키락의 일부로 자주 사용된다.

🔹 **예제: 갭 락이 없을 때 발생할 수 있는 문제**

```sql
-- 트랜잭션 1: 특정 범위를 읽고 있음
SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE;
-- 트랜잭션 2: 새로운 데이터를 삽입
INSERT INTO users(id, name) VALUES (15, 'Alice');
```

**트랜잭션 1이 조회한 데이터와 트랜잭션 2가 삽입한 데이터가 충돌하여 복제 오류가 발생할 가능성이 있음. 갭 락을 사용하면 트랜잭션 1이 실행되는 동안, id 10~20 사이에 새로운 INSERT를 방지하여 일관성을 유지할 수 있음.**

### 🤔 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금

InnoDB의 갭 락이나 넥스트 키락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.

예제: 갭 락 없이 INSERT 실행 시 레플리카 서버에서 문제 발생 가능

```sql
--- 소스 서버에서 실행된 트랜잭션
SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE;
--- 소스 서버에서 실행된 INSERT
INSERT INTO users(id, name) VALUES (15, 'Alice');
--- 바이너리 로그를 통해 레플리카 서버에서도 실행되지만, 그사이에 레플리카 서버에 다른 트랜잭션이 id = 15를 삽입했다면?
INSERT INTO users(id, name) VALUES (15, 'Bob'); -- 다른 트랜잭션이 실행
```

### 🤔 자동 증가 락

AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야한다. 그렇기에 짧은 순간에 락을 건다.

```sql
innodb_autoinc_lock_mode = 0
--- 모든 INSERT 문장은 자동 증가 락을 사용한다.
innodb_autoinc_lock_mode = 1
--- 단순히 한 건 또는 여러 건의 레코드를 INSERT 하는 SQL 중에서 MYSQL 서버가 INSERT되는
--- 레코드의 건수를 정확히 예측가능하면 사용하지 않는다.
innodb_autoinc_lock_mode = 2
--- InnoDB 스토리지 엔진은 절대 자동 증가 락을 걸지 않고 경량화된 래치(뮤텍스)를 사용한다
```

# 💡 트랜잭션 격리 수준

여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션을 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

READ UNCOMMITED → READ COMMITTED → REPREATABLE READ → SERIALIZABLE

뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지고, 동시 처리 성능도 떨어진다. SERIALIZABLE 격리 수준이 아니면 크게 성능의 개선이나 저하는 발생하지 않는다.

### ❓ 더티 리드

어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상

### ❓ MVCC(Mulit Version Concurrency Control)

MVCC는 데이터베이스의 동시성을 높이면서도 트랜잭션 간의 충돌을 줄이기 위한 기술. 즉, 여러 트랜잭션이 동시에 같은 데이터를 읽고 수정할 수 있도록 각 트랜잭션마다 데이터의 스냅샷을 제공한다.

## 1. READ UNCOMMITED

트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에 보인다.

## 2. READ COMMITED

온라인 서비스에서 가장 많이 선택되는 격리 수준이다. 더티 리드 현상은 발생하지 않는다. 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.

SELECT  쿼리를 실행했을 때는 항상 같은 결과를 가져와야하는 REPEATABLE READ 정합성에 어긋난다.

## 3. REPEATABLE READ

NON-REPEATABLE READ 부정합이 발생하지 않는다.

REAPEATABLE READ와 READ COMMITED의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번 째 이전 버전까지 찾아 들어가냐이다.

실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수가 없다.

다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다하는 PHANTOM READ 현상이 발생할 수 있다.

### 4. SERIALIZABLE

읽기 작업도 공유 잠금을 획득해야햐만 하고 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못한다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.